# -*- coding: utf-8 -*-
"""Taller_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DyLG4NjQgsUjWKG4myFVplVdXOEHroW6
"""

import matplotlib.pyplot as plt
import numpy as np

fig, ax = plt.subplots()

# --- Cuerpo de la casa (cuadrado) ---
casa_x = [0, 0, 2, 2, 0]
casa_y = [0, 2, 2, 0, 0]
ax.plot(casa_x, casa_y, 'brown')

# --- Techo (triángulo) ---
techo_x = [0, 1, 2, 0]
techo_y = [2, 3, 2, 2]
ax.plot(techo_x, techo_y, 'red')

# --- Puerta (rectángulo) ---
puerta_x = [0.8, 0.8, 1.2, 1.2, 0.8]
puerta_y = [0, 1, 1, 0, 0]
ax.plot(puerta_x, puerta_y, 'black')

# --- Ventana (cuadrado pequeño) ---
ventana_x = [0.3, 0.3, 0.7, 0.7, 0.3]
ventana_y = [0.8, 1.2, 1.2, 0.8, 0.8]
ax.plot(ventana_x, ventana_y, 'blue')

# Configuración
ax.set_aspect('equal')
ax.set_xlim(-1, 5)
ax.set_ylim(-1, 5)
ax.axis('off')

plt.show()

# --- Variables de traslación ---
dx = 3.5   # desplazamiento en X
dy = 0.5  # desplazamiento en Y

# --- Función de traslación con matrices homogéneas ---
def traslacion(x, y, dx, dy):
    T = np.array([[1, 0, dx],
                  [0, 1, dy],
                  [0, 0,  1]])
    puntos = np.column_stack([x, y, np.ones(len(x))])  # (N x 3)
    puntos_t = (T @ puntos.T).T
    return puntos_t[:,0], puntos_t[:,1]

# Aplicar traslación a cada figura
casa_x_t, casa_y_t = traslacion(casa_x, casa_y, dx, dy)
techo_x_t, techo_y_t = traslacion(techo_x, techo_y, dx, dy)
puerta_x_t, puerta_y_t = traslacion(puerta_x, puerta_y, dx, dy)
ventana_x_t, ventana_y_t = traslacion(ventana_x, ventana_y, dx, dy)

# Dibujar resultado
fig, ax = plt.subplots()
ax.plot(casa_x_t, casa_y_t, 'brown')
ax.plot(techo_x_t, techo_y_t, 'red')
ax.plot(puerta_x_t, puerta_y_t, 'black')
ax.plot(ventana_x_t, ventana_y_t, 'blue')

# Ajustar límites para ver la traslación
ax.set_aspect('equal')
ax.set_xlim(-1, 5)
ax.set_ylim(-1, 5)
ax.axis('off')
plt.show()

# --- Variable de rotación ---
angulo = 90   # grados

# --- Función de rotación con matrices homogéneas ---
def rotacion(x, y, angulo):
    a = np.deg2rad(angulo)
    R = np.array([[ np.cos(a), -np.sin(a), 0],
                  [ np.sin(a),  np.cos(a), 0],
                  [ 0,          0,         1]])
    puntos = np.column_stack([x, y, np.ones(len(x))])  # (N x 3)
    puntos_t = (R @ puntos.T).T
    return puntos_t[:,0], puntos_t[:,1]

# Aplicar rotación a cada figura
casa_x_r, casa_y_r = rotacion(casa_x, casa_y, angulo)
techo_x_r, techo_y_r = rotacion(techo_x, techo_y, angulo)
puerta_x_r, puerta_y_r = rotacion(puerta_x, puerta_y, angulo)
ventana_x_r, ventana_y_r = rotacion(ventana_x, ventana_y, angulo)

# Dibujar resultado
fig, ax = plt.subplots()
ax.plot(casa_x_r, casa_y_r, 'brown')
ax.plot(techo_x_r, techo_y_r, 'red')
ax.plot(puerta_x_r, puerta_y_r, 'black')
ax.plot(ventana_x_r, ventana_y_r, 'blue')

# Ajustar límites
ax.set_aspect('equal')
ax.set_xlim(-4, 1)
ax.set_ylim(-1, 4)
ax.axis('off')
plt.show()

# --- Variables de escala ---
sx = 2.1   # escala en X (50%)
sy = 2.1   # escala en Y (50%)

# --- Función de escala con matrices homogéneas ---
def escalado(x, y, sx, sy):
    S = np.array([[sx, 0, 0],
                  [0, sy, 0],
                  [0,  0, 1]])
    puntos = np.column_stack([x, y, np.ones(len(x))])  # (N x 3)
    puntos_t = (S @ puntos.T).T
    return puntos_t[:,0], puntos_t[:,1]

# Aplicar escalado a cada figura
casa_x_s, casa_y_s = escalado(casa_x, casa_y, sx, sy)
techo_x_s, techo_y_s = escalado(techo_x, techo_y, sx, sy)
puerta_x_s, puerta_y_s = escalado(puerta_x, puerta_y, sx, sy)
ventana_x_s, ventana_y_s = escalado(ventana_x, ventana_y, sx, sy)

# Dibujar resultado
fig, ax = plt.subplots()
ax.plot(casa_x_s, casa_y_s, 'brown')
ax.plot(techo_x_s, techo_y_s, 'red')
ax.plot(puerta_x_s, puerta_y_s, 'black')
ax.plot(ventana_x_s, ventana_y_s, 'blue')

# Ajustar límites
ax.set_aspect('equal')
ax.set_xlim(-1, 5)
ax.set_ylim(-1, 5)
ax.axis('off')
plt.show()

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
from IPython.display import HTML

# --- Funciones de transformación ---
def traslacion(dx, dy):
    return np.array([[1, 0, dx],
                     [0, 1, dy],
                     [0, 0,  1]])

def rotacion(angulo):
    a = np.deg2rad(angulo)
    return np.array([[ np.cos(a), -np.sin(a), 0],
                     [ np.sin(a),  np.cos(a), 0],
                     [ 0,          0,         1]])

def escala(sx, sy):
    return np.array([[sx, 0, 0],
                     [0, sy, 0],
                     [0,  0, 1]])

# --- Aplicar matriz homogénea a puntos ---
def aplicar_transformacion(x, y, M):
    puntos = np.column_stack([x, y, np.ones(len(x))])
    puntos_t = (M @ puntos.T).T
    return puntos_t[:,0], puntos_t[:,1]

# --- Configuración inicial ---
fig, ax = plt.subplots()
line_casa, = ax.plot([], [], 'brown')
line_techo, = ax.plot([], [], 'red')
line_puerta, = ax.plot([], [], 'black')
line_ventana, = ax.plot([], [], 'blue')

ax.set_aspect('equal')
ax.set_xlim(-5, 10)
ax.set_ylim(-5, 10)
ax.axis('off')

# --- Función de actualización ---
def update(frame):
    dx = frame * 0.5             # traslación hacia la derecha
    angulo = frame * 5           # rotación progresiva
    scale = 0.5 + frame * 0.08   # escala creciente

    # Matriz combinada: primero escala, luego rotación, luego traslación
    M = traslacion(dx, 0) @ rotacion(angulo) @ escala(scale, scale)

    casa_x_t, casa_y_t = aplicar_transformacion(casa_x, casa_y, M)
    techo_x_t, techo_y_t = aplicar_transformacion(techo_x, techo_y, M)
    puerta_x_t, puerta_y_t = aplicar_transformacion(puerta_x, puerta_y, M)
    ventana_x_t, ventana_y_t = aplicar_transformacion(ventana_x, ventana_y, M)

    line_casa.set_data(casa_x_t, casa_y_t)
    line_techo.set_data(techo_x_t, techo_y_t)
    line_puerta.set_data(puerta_x_t, puerta_y_t)
    line_ventana.set_data(ventana_x_t, ventana_y_t)

    return line_casa, line_techo, line_puerta, line_ventana

# Crear animación
ani = FuncAnimation(fig, update, frames=30, interval=200, blit=True)

# Mostrar en Colab
HTML(ani.to_jshtml())